/*
 * Copyright (c) 2012-2014 Wind River Systems, Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr.h>
#include <sys/printk.h>
#include <cmsis_os2.h>
#include <logging/log.h>
#include <logging/log_ctrl.h>
#include "mctp.h"
#include "pldm.h"

LOG_MODULE_REGISTER(mctp_test);

#define MCTP_SMBUS_NUM 1

#define MCTP_MSG_TYPE_SHIFT 0
#define MCTP_MSG_TYPE_MASK 0x7F
#define MCTP_IC_SHIFT 7
#define MCTP_IC_MASK 0x80

typedef struct _mctp_smbus_port {
	mctp *mctp_inst;
	mctp_medium_conf conf;
} mctp_smbus_port;

/* mctp route entry struct */
typedef struct _mctp_route_entry {
    uint8_t endpoint;
    uint8_t bus; /* TODO: only consider smbus/i3c */
    uint8_t addr; /* TODO: only consider smbus/i3c */
} mctp_route_entry;

typedef struct _mctp_msg_handler {
	MCTP_MSG_TYPE type;
	mctp_fn_cb msg_handler_cb;
} mctp_msg_handler;

static mctp_msg_handler cmd_tbl[] = {
	{MCTP_MSG_TYPE_PLDM, mctp_pldm_cmd_handler}
};

static mctp_smbus_port smbus_port[MCTP_SMBUS_NUM] = {
	{.conf.smbus_conf.addr = 0xB2, .conf.smbus_conf.bus = 0x01},
	// {.conf.smbus_conf.addr = 0x20, .conf.smbus_conf.bus = 0x02}
};

mctp_route_entry mctp_route_tbl[] = {
	{0x11, 0x01, 0x41},
	{0x12, 0x02, 0x42},
	{0x13, 0x01, 0x43},
	{0x14, 0x02, 0x44},
	{0x15, 0x01, 0x45},
	{0x16, 0x02, 0x46}
};

static mctp *find_mctp_by_smbus(uint8_t bus)
{
	uint8_t i;
	for (i = 0; i < MCTP_SMBUS_NUM; i++) {
		mctp_smbus_port *p = smbus_port + i;
		
		if (bus == p->conf.smbus_conf.bus)
			return p->mctp_inst;
	}

	return NULL;
}

uint8_t mctp_control_cmd_handler(void *mctp_p, uint8_t src_ep, uint8_t *buf, uint32_t len, mctp_ext_param ext_params)
{
	mctp_printf("\n");
	if (!mctp_p || !buf || !len)
		return MCTP_ERROR;

	return MCTP_SUCCESS;
}

static uint8_t mctp_msg_recv(void *mctp_p, uint8_t *buf, uint32_t len, mctp_ext_param ext_params)
{
	if (!mctp_p || !buf || !len)
		return MCTP_ERROR;
	
	/* first byte is message type and ic */
	uint8_t msg_type = (buf[0] & MCTP_MSG_TYPE_MASK) >> MCTP_MSG_TYPE_SHIFT;
	uint8_t ic = (buf[0] & MCTP_IC_MASK) >> MCTP_IC_SHIFT;
	(void)ic;
	
	uint8_t i;
	for (i = 0; i < sizeof(cmd_tbl) / sizeof(*cmd_tbl); i++) {
		if (cmd_tbl[i].type == msg_type) {
			cmd_tbl[i].msg_handler_cb(mctp_p, buf, len, ext_params);
			break;
		}
	}

	return MCTP_SUCCESS;
}

static uint8_t get_route_info(uint8_t dest_endpoint, void **mctp_inst, mctp_ext_param *ext_params)
{
	if (!mctp_inst || !ext_params)
		return MCTP_ERROR;

	uint8_t rc = MCTP_ERROR;
	uint32_t i;

	for (i = 0; ARRAY_SIZE(mctp_route_tbl); i++) {
		mctp_route_entry *p = mctp_route_tbl + i;
		if (p->endpoint == dest_endpoint) {
			*mctp_inst = find_mctp_by_smbus(p->bus);
			ext_params->type = MCTP_MEDIUM_TYPE_SMBUS;
			ext_params->smbus_ext_param.addr = p->addr;
			rc = MCTP_SUCCESS;
			break;
		}
	}

	return rc;
}

static void main_gettid(void *args, uint8_t *buf, uint16_t len)
{
	LOG_DBG("");
}

static void to_test(void *to_args)
{
	uint8_t *i = (uint8_t *)to_args;
	LOG_DBG("*i = %d", *i);
}

void main(void)
{
	LOG_DBG("MCTP test");

	uint32_t i;
	for (i = 0; i < MCTP_SMBUS_NUM; i++) {
		mctp_smbus_port *p = smbus_port + i;
		LOG_DBG("smbus port %d", i);
		LOG_DBG("bus = %x, addr = %x", p->conf.smbus_conf.bus, p->conf.smbus_conf.addr);

		p->mctp_inst = mctp_init();
		if (!p->mctp_inst) {
			LOG_ERR("mctp_init failed!!");
			continue;
		}

		uint8_t rc = mctp_set_medium_configure(p->mctp_inst, MCTP_MEDIUM_TYPE_SMBUS, p->conf);
		LOG_DBG("mctp_set_medium_configure %s", (rc == MCTP_SUCCESS)? "success": "failed");

		/* test get medium function */
		MCTP_MEDIUM_TYPE medium_type = MCTP_MEDIUM_TYPE_UNKNOWN;
		mctp_medium_conf medium_conf;
		rc = mctp_get_medium_configure(p->mctp_inst, &medium_type, &medium_conf);
		LOG_DBG("mctp_get_medium_configure %s", (rc == MCTP_SUCCESS)? "success": "failed");
		LOG_DBG("medium_type = %d", medium_type);
		LOG_DBG("smbus bus = %x, addr = %x", medium_conf.smbus_conf.bus, medium_conf.smbus_conf.addr);

		mctp_reg_endpoint_resolve_func(p->mctp_inst, get_route_info);
		mctp_reg_msg_rx_func(p->mctp_inst, mctp_msg_recv);
		mctp_start(p->mctp_inst);
	}

	pldm_init();

	while (1) {
		k_msleep(1000);

		mctp_ext_param ext_param = {0};
		ext_param.type = MCTP_MEDIUM_TYPE_SMBUS;
		ext_param.smbus_ext_param.addr = 0x80;
		ext_param.ep = 0x78;

		pldm_msg msg = {0};
		msg.hdr.pldm_type = PLDM_TYPE_BASE;
		msg.hdr.cmd = PLDM_BASE_CMD_CODE_GETTID;
		msg.hdr.rq = 1;
#if 1
		// mctp_pldm_send_msg(smbus_port[0].mctp_inst, &msg, ext_param, main_gettid, NULL);
		static uint8_t i = 78;
		mctp_pldm_send_msg_with_timeout(smbus_port[0].mctp_inst, &msg, ext_param, main_gettid, NULL, 5000, to_test, &i);
		i++;
#endif
#if 0
		if (!(i % 1000)) {
			uint8_t buf[] = {0x01,0x00,0x05,0x15,0x00,0x22,0x00,0x00,0xEA,
				0x03,0xA5,0xEA,0x5A,0xA5,0xEA,0x5A,0xA5,0xEA,0x5A,0xA5,0x5A,0x77,0x46,0x74,0x41,
				0x28,0x00,0x00,0x00,0xE5,0xD0,0xE4,0xDC,0x00,0x02,0x02,0x91,0x01,0x00,0xFF,0xFF,
				0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3C,0x00,0x00,0x00,0xC0,0xD8,0x06,0x00,
				0x7C,0x05,0x00,0x00,0xC0,0xD8,0x06,0x00,0x64
			};
			mctp_ext_param ext_param = {0};
			ext_param.type = MCTP_MEDIUM_TYPE_SMBUS;
			ext_param.smbus_ext_param.addr = 0x80;

			ext_param.msg_tag = 0;
			ext_param.tag_owner = 1;
			ext_param.ep = 6;

			mctp_send_msg(smbus_port[0].mctp_inst, buf, sizeof(buf), ext_param);
		}

		if (!(i % 2000)) {
			uint8_t buf[] = {0x01,0x00,0x05,0x15,0x00,0x22,0x00,0x00,0xEA,
				0x03,0xA5,0xEA,0x5A,0xA5,0xEA,0x5A,0xA5,0xEA,0x5A,0xA5,0x5A,0x77,0x46,0x74,0x41,
				0x28,0x00,0x00,0x00,0xE5,0xD0,0xE4,0xDC,0x00,0x02,0x02,0x91,0x01,0x00,0xFF,0xFF,
				0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3C,0x00,0x00,0x00,0xC0,0xD8,0x06,0x00,
				0x7C,0x05,0x00,0x00,0xC0,0xD8,0x06,0x00,0x65,0x01,0x00,0x05,0x15,0x00,0x22,0x00,0x00,0xEA,
				0x03,0xA5,0xEA,0x5A,0xA5,0xEA,0x5A,0xA5,0xEA,0x5A,0xA5,0x5A,0x77,0x46,0x74,0x41,
				0x28,0x00,0x00,0x00,0xE5,0xD0,0xE4,0xDC,0x00,0x02,0x02,0x91,0x01,0x00,0xFF,0xFF,
				0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3C,0x00,0x00,0x00,0xC0,0xD8,0x06,0x00,
				0x7C,0x05,0x00,0x00,0xC0,0xD8,0x06,0x00,0x65,0x01,0x00,0x05,0x15,0x00,0x22,0x00,0x00,0xEA,
				0x03,0xA5,0xEA,0x5A,0xA5,0xEA,0x5A,0xA5,0xEA,0x5A,0xA5,0x5A,0x77,0x46,0x74,0x41,
				0x28,0x00,0x00,0x00,0xE5,0xD0,0xE4,0xDC,0x00,0x02,0x02,0x91,0x01,0x00,0xFF,0xFF,
				0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3C,0x00,0x00,0x00,0xC0,0xD8,0x06,0x00,
				0x7C,0x05,0x00,0x00,0xC0,0xD8,0x06,0x00,0x65,0x01,0x00,0x05,0x15,0x00,0x22,0x00,0x00,0xEA,
				0x03,0xA5,0xEA,0x5A,0xA5,0xEA,0x5A,0xA5,0xEA,0x5A,0xA5,0x5A,0x77,0x46,0x74,0x41,
				0x28,0x00,0x00,0x00,0xE5,0xD0,0xE4,0xDC,0x00,0x02,0x02,0x91,0x01,0x00,0xFF,0xFF,
				0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3C,0x00,0x00,0x00,0xC0,0xD8,0x06,0x00,
				0x7C,0x05,0x00,0x00,0xC0,0xD8,0x06,0x00,0x65
			};
			mctp_ext_param ext_param = {0};
			ext_param.type = MCTP_MEDIUM_TYPE_SMBUS;
			ext_param.smbus_ext_param.addr = 0x60;

			ext_param.msg_tag = 0;
			ext_param.tag_owner = 1;
			ext_param.ep = 7;

			mctp_send_msg(smbus_port[0].mctp_inst, buf, sizeof(buf), ext_param);
		}
#endif
	}
}